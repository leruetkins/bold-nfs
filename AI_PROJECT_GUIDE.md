# AI Project Guide: Bold NFS Server

## Резюме

Проект **Bold** — это реализация сервера Network File System (NFS) версии 4.0, написанная на асинхронном Rust с использованием Tokio. Цель проекта — создать простой, надежный, портируемый, расширяемый и производительный NFS-сервер.

Архитектура представляет собой монорепозиторий с Cargo-воркспейсом, разделенным на три крейта:
1.  `proto`: Содержит определения структур данных и кодеки для протоколов RPC и NFSv4, используя `serde-xdr`.
2.  `lib`: Основная библиотека, реализующая логику NFS-сервера. Она включает акторы для управления клиентами (`ClientManager`) и файлами/файловыми хендлами (`FileManager`), а также обработку операций NFSv4.0. Взаимодействие с файловой системой абстрагировано через `vfs`.
3.  `exec`: Предоставляет два исполняемых файла для демонстрации и тестирования: `bold-mem` для работы с файловой системой в памяти и `bold-nfs` для "расшаривания" реальной директории.

Точкой входа является TCP-сервер, который обрабатывает входящие RPC-сообщения, разбирает их и последовательно выполняет NFS-операции в рамках `COMPOUND` запроса. Состояние клиентов и файловых хендлов управляется централизованно через акторы, что обеспечивает консистентность.

## Оглавление

1.  [Overview](#1-overview)
2.  [Architecture](#2-architecture)
3.  [Back-end](#3-back-end)
4.  [Front-end](#4-front-end)
5.  [Data & Storage](#5-data--storage)
6.  [External & Integrations](#6-external--integrations)
7.  [Build & Run](#7-build--run)
8.  [Quality & Ops](#8-quality--ops)
9.  [Conventions & Examples](#9-conventions--examples)
10. [Open Questions & Risks](#10-open-questions--risks)
11. [Changelog Summary](#11-changelog-summary)

---

## 1. Overview

**Цели проекта:**
- **Простота:** Код должен быть понятным, без излишних усложнений и "магии" типов/макросов.
- **Надежность:** Сервер должен быть стабильным и корректно обрабатывать ошибки.
- **Портируемость:** Возможность запуска на различных ОС, где работает Rust/Tokio.
- **Расширяемость:** Архитектура должна позволять добавлять поддержку новых минорных версий NFS и новых операций.
- **Производительность:** Эффективная обработка запросов.

**Доменная область:**
Проект реализует серверную часть протокола NFSv4.0. Это сетевая файловая система, позволяющая клиентам получать доступ к файлам на удаленном сервере так, как если бы они находились на локальной машине. Ключевые концепции:
- **Файловые хендлы (Filehandles):** Уникальные идентификаторы файлов и директорий, используемые клиентом для доступа к объектам.
- **Операции (Operations):** Атомарные действия над файловой системой (например, `LOOKUP`, `READ`, `WRITE`, `CREATE`).
- **COMPOUND-запросы:** Пакет из нескольких операций, который выполняется на сервере атомарно.
- **Клиенты (Clients) и сессии:** Управление состоянием подключенных клиентов.
- **Атрибуты:** Метаданные файлов (размер, права доступа, время модификации и т.д.).
- **Блокировки (Locking):** Механизмы для управления одновременным доступом к файлам.

---

## 2. Architecture

Проект имеет многослойную архитектуру, реализованную в виде Cargo-воркспейса.

**Структура воркспейса:**
- **`proto`**: Крейт для работы с протоколом. Он отвечает за (де)сериализацию XDR-сообщений.
  - [`proto/src/rpc_proto.rs`](proto/src/rpc_proto.rs): Определения для общего RPC-протокола (на основе RFC 1057).
  - [`proto/src/nfs4_proto.rs`](proto/src/nfs4_proto.rs): Определения для протокола NFSv4.0 (на основе RFC 7530). Для поддержки не-ASCII символов, имена файлов и другие потенциально не-ASCII строки представлены как `Vec<u8>`, а не `String`.
  - [`proto/src/lib.rs`](proto/src/lib.rs): Реализация `XDRProtoCodec` для `tokio-util`, который преобразует байтовый поток TCP в последовательность RPC-сообщений.
- **`lib`**: Основная библиотека сервера.
  - [`lib/src/lib.rs`](lib/src/lib.rs): Содержит `NFSServer` и `ServerBuilder`. Здесь находится главный цикл обработки TCP-соединений.
  - [`lib/src/server/mod.rs`](lib/src/server/mod.rs): Определяет трейт `NfsProtoImpl` и структуру `NFSService`, которая диспетчеризует вызовы к конкретной реализации протокола.
  - [`lib/src/server/nfs40.rs`](lib/src/server/nfs40.rs): Реализация `NfsProtoImpl` для NFSv4.0. Диспетчеризует операции из `COMPOUND`-запроса.
  - [`lib/src/server/nfs40/op_*.rs`](lib/src/server/nfs40/op_*.rs): Модули, реализующие логику отдельных NFS-операций (`GETATTR`, `LOOKUP` и т.д.).
  - [`lib/src/server/filemanager/mod.rs`](lib/src/server/filemanager/mod.rs): Актор `FileManager`, управляющий состоянием файловой системы (хендлы, атрибуты, блокировки).
  - [`lib/src/server/clientmanager.rs`](lib/src/server/clientmanager.rs): Актор `ClientManager`, управляющий состоянием клиентов.
- **`exec`**: Исполняемые файлы.
  - [`exec/src/main.rs`](exec/src/main.rs): Бинарный файл `bold-mem` для запуска сервера с VFS в памяти.
  - [`exec/src/main_real_fs.rs`](exec/src/main_real_fs.rs): Бинарный файл `bold-nfs` для запуска сервера с реальной ФС.

**Поток данных (Data Flow):**
1. Клиент устанавливает TCP-соединение с сервером.
2. `NFSServer` в [`lib/src/lib.rs`](lib/src/lib.rs) принимает соединение.
3. `XDRProtoCodec` декодирует байтовый поток в `RpcCallMsg`.
4. `NFSService` получает `RpcCallMsg` и вызывает соответствующий метод у реализации протокола (`NFS40Server`).
5. `NFS40Server` обрабатывает `COMPOUND`-запрос, последовательно выполняя каждую операцию.
6. Каждая операция (`op_*.rs`) взаимодействует с `FileManager` и `ClientManager` для получения/изменения состояния.
7. `FileManager` использует `vfs` крейт для взаимодействия с нижележащей файловой системой (реальной или в памяти).
8. Результат выполнения операции формируется в `RpcReplyMsg` и отправляется клиенту через `XDRProtoCodec`.

**Ключевые зависимости:**
- `tokio`: Асинхронный рантайм.
- `serde`, `serde-xdr`: Для (де)сериализации.
- `vfs`: Абстракция над виртуальной файловой системой.
- `clap`: Парсинг аргументов командной строки.
- `tracing`: Логирование.
- `multi_index_map`: Для хранения состояний клиентов с возможностью поиска по разным ключам.

---

## 3. Back-end

Бэкенд представляет собой единый TCP-сервер, написанный на Rust.

**Фреймворки:**
- Основа: `tokio`.
- Веб-фреймворк: Отсутствует, используется низкоуровневая работа с TCP.

**Точки входа:**
- `main()` в [`exec/src/main.rs`](exec/src/main.rs) (`bold-mem`).
- `main()` в [`exec/src/main_real_fs.rs`](exec/src/main_real_fs.rs) (`bold-nfs`).

Оба бинарника создают `ServerBuilder`, конфигурируют его и вызывают `server.start()`, который запускает `tokio` рантайм и вечный цикл приема соединений.

**Маршруты и обработчики (NFS Operations):**
Маршрутизация происходит внутри `NFS40Server::compound`. Каждая операция из `argarray` `COMPOUND`-запроса матчится и передается на исполнение соответствующему модулю `op_*.rs`.

Примеры реализованных операций:
- `op_set_clientid`, `op_set_clientid_confirm`: Регистрация клиента.
- `op_putfh`, `op_putrootfh`: Установка текущего файлового хендла.
- `op_getattr`: Получение атрибутов файла.
- `op_lookup`: Поиск файла в директории.
- `op_read`, `op_write`: Чтение и запись данных.
- `op_create`, `op_remove`: Создание и удаление файлов.
- `op_open`, `op_close`: Открытие и закрытие файлов с управлением состоянием.

**Middleware (Actors):**
Вместо классического middleware используются акторы для управления разделяемым состоянием:
- `ClientManager`: Управляет жизненным циклом клиентов. Запускается в [`lib/src/lib.rs`](lib/src/lib.rs) и доступен через `ClientManagerHandle`.
- `FileManager`: Управляет файловыми хендлами, блокировками, кешем записи. Запускается там же и доступен через `FileManagerHandle`.
Взаимодействие с акторами происходит через отправку сообщений по `mpsc` каналам.

**Конфигурация:**
- Конфигурация сервера происходит через `ServerBuilder` ([`lib/src/lib.rs:132`](lib/src/lib.rs:132)).
- Исполняемые файлы используют `clap` для парсинга аргументов командной строки (путь к ФС, флаг дебага).
- `bold-mem` дополнительно читает YAML-файл для построения файловой системы в памяти.

---

## 4. Front-end

В данном проекте отсутствует фронтенд. Это исключительно бэкенд-приложение (NFS-сервер).

---

## 5. Data & Storage

**Схемы таблиц (In-memory DB):**
Хранение состояний реализовано в памяти с помощью `HashMap` и `multi_index_map`.

- **`ClientManager`**:
  - `db: MultiIndexClientEntryMap`: Хранит записи о клиентах (`ClientEntry`). Позволяет делать быстрые выборки по `principal`, `verifier`, `id`, `clientid`, `setclientid_confirm`.
    - [`lib/src/server/clientmanager.rs:31`](lib/src/server/clientmanager.rs:31). Идентификатор клиента (`id`) хранится в виде `Vec<u8>` для поддержки UTF-8.
- **`FileManager`**:
  - `fhdb: FilehandleDb`: Индекс для `Filehandle` по `id` (NfsFh4) и `path` (String).
    - [`lib/src/server/filemanager/filehandle.rs`](lib/src/server/filemanager/filehandle.rs)
  - `lockdb: LockingStateDb`: Индекс для `LockingState` по `filehandle_id` и `stateid`.
    - [`lib/src/server/filemanager/locking.rs`](lib/src/server/filemanager/locking.rs)
  - `cachedb: HashMap<NfsFh4, WriteCacheHandle>`: Кеш для операций записи.

**Миграции:**
Отсутствуют, так как состояние хранится в памяти и не является персистентным между перезапусками сервера.

**Связи:**
- `ClientEntry` не имеет прямых связей с другими структурами.
- `Filehandle` связан с `LockingState` через `filehandle.id`. `FileManager` "присоединяет" блокировки к файловому хендлу при его получении.

**Хранилище:**
- Основное хранилище — это абстракция `vfs::VfsPath`.
- `bold-mem` использует `vfs::MemoryFS`.
- `bold-nfs` использует `vfs::PhysicalFS`, который является оберткой над реальной файловой системой ОС.

---

## 6. External & Integrations

- **NFS Client:** Основная интеграция — это взаимодействие с любым NFSv4.0-совместимым клиентом (например, `mount.nfs4` в Linux).
- **API:** Внешний API — это протокол NFSv4.0 поверх RPC.
- **Брокеры / Очереди:** Не используются.
- **SMTP:** Не используется.

---

## 7. Build & Run

**Команды для сборки:**
- Сборка всего проекта: `cargo build`
- Сборка в release-режиме: `cargo build --release`

**Переменные окружения:**
- Не используются. Конфигурация передается через аргументы командной строки.

**Профили запуска:**

1.  **In-memory FS (`bold-mem`)**
    - Запускает сервер с файловой системой в памяти, определенной в YAML-файле.
    - **Команда:**
      ```bash
      cargo run -p bold-exec --bin bold-mem -- [--debug] <path/to/memoryfs.yaml>
      ```
    - Пример монтирования в Linux:
      ```bash
      sudo mount.nfs4 -n -v -o fg,soft,sec=none,vers=4.0,port=11112,lookupcache=none,actimeo=0 127.0.0.1:/ /tmp/demo
      ```

2.  **Real FS (`bold-nfs`)**
    - Запускает сервер, который "расшаривает" указанную директорию.
    - **Команда:**
      ```bash
      cargo run -p bold-exec --bin bold-nfs -- <path/to/your/directory>
      ```
    - Пример монтирования аналогичен `bold-mem`.

---

## 8. Quality & Ops

**Логирование:**
- Используется крейт `tracing`.
- Уровень логирования (`INFO` или `DEBUG`) устанавливается флагом `--debug` при запуске.
- Сообщения выводятся в `stdout`.

**Метрики:**
- Не реализованы. `TODO`: Можно добавить метрики для количества операций, ошибок, активных клиентов и т.д. с помощью `prometheus` или аналогичного крейта.

**Тестирование:**
- **Unit-тесты:** Присутствуют в некоторых модулях, например в `clientmanager.rs`. Запускаются командой `cargo test`.
- **Интеграционные тесты:** Отсутствуют в кодовой базе Rust, но есть Python-тесты в директории `tests/`.
  - `tests/integration/test_one_client.py`: Тестирует базовые операции с одним клиентом.
  - `pyproject.toml` и `poetry.lock` указывают на использование `poetry` для управления зависимостями Python.
  - `TODO`: Необходимо описать, как запускать эти тесты.

**CI/CD:**
- Файлы CI/CD в репозитории отсутствуют. `TODO`: Создать GitHub Actions (или аналог) для автоматической сборки и запуска тестов.

**Безопасность:**
- Реализован только механизм аутентификации `AUTH_NULL`.
- `TODO`: Необходимо добавить поддержку более безопасных механизмов, таких как `RPCSEC_GSS`.
- Обработка путей: Используется `vfs`, что должно предотвращать атаки типа "path traversal", так как все пути резолвятся относительно корневой директории VFS.

---

## 9. Conventions & Examples

**Стиль кода:**
- Стандартный `rustfmt`.
- Активно используется паттерн "Актор" для управления состоянием (`ClientManager`, `FileManager`).
- Асинхронный код с `async/await` и `tokio`.

**Коммиты и ветки:**
- Соглашения не задокументированы.

**Примеры кода (шаблоны):**

- **Добавление новой NFS-операции:**
  1.  Создать новый файл `lib/src/server/nfs40/op_new_op.rs`.
  2.  Определить структуру для аргументов (`NewOp4args`) и реализовать для нее трейт `NfsOperation`.
  3.  В `execute` реализовать логику операции.
  4.  Добавить `mod op_new_op;` в `lib/src/server/nfs40.rs`.
  5.  В `NFS40Server::compound` добавить ветку для `NfsArgOp::OpNewOp(args) => args.execute(request).await`.
  6.  Добавить определения для `NewOp4args` и `NewOp4res` в `proto/src/nfs4_proto.rs`.

---

## 10. Open Questions & Risks

- **Управление состоянием:** Все состояние хранится в памяти. При падении сервера все сессии клиентов, блокировки и т.д. будут потеряны. Является ли это приемлемым?
- **Производительность:** Как сервер будет вести себя под высокой нагрузкой? Акторы могут стать узким местом. Требуется нагрузочное тестирование.
- **Полнота реализации NFSv4.0:** Многие операции не поддерживаются (`status: Nfs4errNotsupp`). Какие из них являются приоритетными для реализации?
- **Безопасность:** Отсутствие надежной аутентификации является серьезным риском.
- **Тестирование:** Интеграционные тесты на Python не интегрированы в общий процесс CI (которого нет). Как их правильно запускать и поддерживать?
- **Обработка ошибок:** Обработка ошибок в некоторых местах сводится к `unwrap()` или `todo!()`. Требуется ревизия и более надежная обработка.

---

## 11. Changelog Summary

### 2025-09-16: Исправление поддержки UTF-8

- **Проблема:** Сервер падал с ошибкой сериализации `StringIsNotAscii` при попытке отобразить файлы с не-ASCII (например, русскими) именами.
- **Решение:**
  - В `proto/src/nfs4_proto.rs` типы данных, представляющие имена файлов и идентификаторы клиентов (например, `Component4`, поле `id` в `NfsClientId4`), были изменены с `String` на `Vec<u8>`. Это позволяет передавать строки как необработанные байты в кодировке UTF-8, избегая проблем при XDR-сериализации, которая по умолчанию ожидает ASCII.
  - В обработчиках операций (`op_*.rs`), где используются эти поля, была добавлена логика для конвертации между `Vec<u8>` и строками (`std::str::from_utf8`).
  - В `ClientManager` поле `id` у `ClientEntry` также было изменено на `Vec<u8>` для консистентности.
- **Результат:** Сервер теперь корректно обрабатывает и отображает файлы с именами в кодировке UTF-8.


---

## 12. Project Structure Diagram

Ниже представлена диаграмма, иллюстрирующая структуру проекта, ключевые модули и логику их взаимодействия.

```markdown
**Bold NFS Server - Project Tree**
│
├── 📂 **exec/** — (Точки входа)
│   ├── 📜 **Cargo.toml**
│   │   └── 📦 `bold` (link to ../lib)
│   │   └── 📦 `clap` (CLI-аргументы)
│   │   └── 📦 `vfs` (для PhysicalFS)
│   │
│   ├── 🚀 **src/main.rs** — (`bold-mem`)
│   │   ├── 🎯 **main()**: Точка входа.
│   │   ├── ⚙️ Парсит CLI-аргументы (`clap`).
│   │   ├── 📄 Читает YAML-файл, создает `MemoryFS` из `vfs`.
│   │   └── 🏁 Создает `ServerBuilder` из `lib`, конфигурирует и запускает `NFSServer`.
│   │
│   └── 🚀 **src/main_real_fs.rs** — (`bold-nfs`)
│       ├── 🎯 **main()**: Точка входа.
│       ├── ⚙️ Парсит CLI-аргументы (`clap`).
│       ├── 🗄️ Создает `PhysicalFS` из `vfs` для указанной директории.
│       └── 🏁 Создает `ServerBuilder` из `lib`, конфигурирует и запускает `NFSServer`.
│
├── 📂 **lib/** — (Ядро сервера)
│   ├── 📜 **Cargo.toml**
│   │   └── 📦 `bold-proto` (link to ../proto)
│   │   └── 📦 `tokio` (Асинхронный рантайм)
│   │   └── 📦 `vfs` (Абстракция ФС)
│   │   └── 📦 `multi_index_map` (In-memory DB для клиентов)
│   │   └── 📦 `async-trait` (Для трейтов с async-методами)
│   │
│   └── 📚 **src/lib.rs**
│       ├── ✨ `NFSServer`: Основная структура сервера.
│       │   └── `start()`: Запускает TCP-listener в рантайме `tokio`.
│       ├── ✨ `ServerBuilder`: Конфигуратор для `NFSServer`.
│       └── 🔄 **Главный цикл обработки соединений**:
│           ├── 1. Принимает `TcpStream`.
│           ├── 2. Оборачивает его в `Framed<_, XDRProtoCodec>` для разбора RPC-сообщений.
│           ├── 3. Создает `NfsRequest` (контекст запроса).
│           ├── 4. Передает сообщение в `NFSService` для обработки.
│           └── 5. Отправляет ответ обратно клиенту.
│
├── 📂 **lib/src/server/** — (Модули сервера)
│   │
│   ├── 📦 **mod.rs**: `NFSService` (диспетчер RPC) и `NfsProtoImpl` (трейт для версий NFS).
│   ├── 📦 **nfs40.rs**: `NFS40Server` — реализация `NfsProtoImpl` для NFSv4.0.
│   │   └── `compound()`: Обрабатывает `COMPOUND` запросы, вызывая нужные операции.
│   │
│   ├── 📂 **nfs40/**: Реализации отдельных NFS-операций (`op_*.rs`).
│   │   └── 📜 `op_getattr.rs`, `op_read.rs`, etc.
│   │       └── `execute()`: Логика операции. Взаимодействует с `FileManager` и `ClientManager`.
│   │
│   ├── 📦 **request.rs**: `NfsRequest` — структура, хранящая контекст одного запроса.
│   │
│   ├── 📂 **filemanager/**: Актор для управления ФС.
│   │   ├── 📜 **mod.rs**: `FileManager` (актор) и `run_file_manager` (цикл актора).
│   │   ├── 📜 **handle.rs**: `FileManagerHandle` — хендл для отправки сообщений актору.
│   │   └── 📜 **filehandle.rs**, **locking.rs**: In-memory "базы данных" для хендлов и блокировок.
│   │
│   └── 📂 **clientmanager.rs**: Актор для управления клиентами.
│       ├── `ClientManager` (актор), `run_client_manager` (цикл).
│       ├── `ClientManagerHandle` (хендл для отправки сообщений).
│       └── `ClientEntry`: Структура с данными клиента.
│
└── 📂 **proto/** — (Протокол и кодек)
    ├── 📜 **Cargo.toml**
    │   └── 📦 `serde-xdr` (Сериализация/десериализация)
    │   └── 📦 `bytes`, `tokio-util` (Работа с байтами и кодеками)
    │
    ├── 📚 **src/lib.rs**: `XDRProtoCodec` — `tokio_util::codec` для преобразования TCP-потока в RPC-сообщения.
    ├── 📜 **src/rpc_proto.rs**: Структуры для RPC (Call, Reply).
    └── 📜 **src/nfs4_proto.rs**: Структуры для NFSv4.0 (Операции, атрибуты, типы данных).
```
